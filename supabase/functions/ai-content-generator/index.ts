import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2";

// --- SHARED: CORS Headers ---
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// --- SHARED: Response Helpers ---
function createErrorResponse(message: string, status = 500, details?: any) {
  return new Response(JSON.stringify({
    success: false,
    error: {
      message,
      details: details || undefined,
    }
  }), {
    status,
    headers: { ...corsHeaders, "Content-Type": "application/json" },
  });
}

function createSuccessResponse(data: object, status = 200) {
  return new Response(JSON.stringify({
    success: true,
    data,
  }), {
    status,
    headers: { ...corsHeaders, "Content-Type": "application/json" },
  });
}

// --- SHARED: Service Handler ---
async function serviceHandler(req: Request, toolLogic: Function) {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  try {
    const supabaseAdminClient = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
    );

    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      return createErrorResponse('Missing Authorization header', 401);
    }

    const supabaseClient = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_ANON_KEY")!,
      { global: { headers: { Authorization: authHeader } } }
    );

    return await toolLogic(req, { supabaseClient, supabaseAdminClient });

  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'An unknown server error occurred.';
    console.error(`[ServiceHandler Error]`, err);
    return createErrorResponse(errorMessage, 500, err instanceof Error ? err.stack : undefined);
  }
}

// --- SHARED: Database Logging Helpers ---
async function logToolRun(supabase: SupabaseClient, projectId: string, toolName: string, inputPayload: object) {
  if (!projectId) {
    throw new Error("logToolRun error: projectId is required.");
  }
  const { data, error } = await supabase
    .from("tool_runs")
    .insert({
      project_id: projectId,
      tool_name: toolName,
      input_payload: inputPayload,
      status: "running",
    })
    .select("id")
    .single();

  if (error) {
    console.error("Error logging tool run:", error);
    throw new Error(`Failed to log tool run. Supabase error: ${error.message}`);
  }
  if (!data || !data.id) {
    console.error("No data or data.id returned from tool_runs insert.");
    throw new Error("Failed to log tool run: No data returned after insert.");
  }
  return data.id;
}

async function updateToolRun(supabase: SupabaseClient, runId: string, status: string, outputPayload: object | null, errorMessage: string | null) {
  if (!runId) {
    console.error("updateToolRun error: runId is required.");
    return;
  }
  const update = {
    status,
    completed_at: new Date().toISOString(),
    output_payload: errorMessage ? { error: errorMessage } : outputPayload || null,
    error_message: errorMessage || null,
  };
  const { error } = await supabase.from("tool_runs").update(update).eq("id", runId);
  if (error) {
    console.error(`Error updating tool run ID ${runId}:`, error);
  }
}

// --- SHARED: Robust AI Call Function ---
async function callGeminiWithRetry(prompt: string, apiKey: string) {
  let attempts = 0;
  const maxAttempts = 4;
  let delay = 1000; // Start with a 1-second delay

  while (attempts < maxAttempts) {
    try {
      const geminiResponse = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0.7,
              maxOutputTokens: 4096,
              topP: 0.8,
              topK: 40,
            },
          }),
        }
      );

      if (!geminiResponse.ok) {
        // Specific check for retryable status codes
        if (geminiResponse.status === 429 || geminiResponse.status === 503) {
            const errorText = await geminiResponse.text();
            throw new Error(`Retryable Gemini API error: ${geminiResponse.status} ${errorText}`);
        }
        const errorText = await geminiResponse.text();
        console.error('Gemini API error:', geminiResponse.status, errorText);
        throw new Error(`Gemini API failed with status ${geminiResponse.status}: ${errorText}`);
      }

      const geminiData = await geminiResponse.json();

      if (!geminiData.candidates || geminiData.candidates.length === 0) {
        console.error('No candidates in Gemini response:', geminiData);
        throw new Error('No content generated by Gemini API');
      }

      const candidate = geminiData.candidates[0];
      if (candidate.finishReason && candidate.finishReason !== 'STOP') {
        throw new Error(`Content generation stopped for reason: ${candidate.finishReason}`);
      }
       if (candidate.safetyRatings?.some(r => r.probability !== 'NEGLIGIBLE')) {
        throw new Error(`Content blocked due to safety ratings: ${JSON.stringify(candidate.safetyRatings)}`);
      }

      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        console.error('No content parts in Gemini response:', candidate);
        throw new Error('Invalid response structure from Gemini API');
      }

      const responseText = candidate.content.parts[0].text;
      console.log('Raw Gemini response text:', responseText.substring(0, 500) + '...');

      // **CRITICAL: Robust JSON parsing**
      const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/);
      if (!jsonMatch || !jsonMatch[1]) {
        console.error('Could not find JSON block in response:', responseText);
        throw new Error('Failed to extract JSON from AI response.');
      }
      const jsonString = jsonMatch[1];
      console.log('Extracted JSON string:', jsonString);

      return JSON.parse(jsonString);

    } catch (error) {
       if (error.message.includes("Retryable")) {
            attempts++;
            console.log(`AI model is overloaded or rate-limited. Retrying in ${delay / 1000}s... (Attempt ${attempts}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
       } else {
           throw error; // Non-retryable error
       }
    }
  }

  throw new Error("The AI model is currently overloaded after multiple retries. Please try again later.");
}


// --- TOOL-SPECIFIC: Type Definitions ---
interface ContentGenerationRequest {
    projectId: string;
    contentType: 'faq' | 'meta-tags' | 'snippets' | 'headings' | 'descriptions';
    topic: string;
    targetKeywords: string[];
    tone?: 'professional' | 'casual' | 'technical' | 'friendly';
    entitiesToInclude?: string[];
}

// --- TOOL-SPECIFIC: AI Prompt Engineering ---
const getContentGenerationPrompt = (request: ContentGenerationRequest) => {
  const { contentType, topic, targetKeywords, tone, entitiesToInclude } = request;
  
  const baseInstructions = {
    'faq': 'Generate 5-7 comprehensive FAQ pairs. Create questions that people commonly ask and provide clear, detailed answers. Format as an array of objects with "question" and "answer" fields.',
    'meta-tags': 'Generate optimized meta tags including title (60 chars max), description (160 chars max), and keywords.',
    'snippets': 'Create featured snippet-optimized content that directly answers common questions. Format as a concise, well-structured response.',
    'headings': 'Generate a comprehensive and logical heading structure with H1, H2s, and H3s that follows SEO best practices.',
    'descriptions': 'Write compelling, SEO-optimized descriptions that clearly explain the topic and include target keywords naturally.'
  };

  const entityInstruction = entitiesToInclude && entitiesToInclude.length > 0 
    ? `**Important: You must naturally integrate these entities into the content:** ${entitiesToInclude.join(', ')}.` 
    : '';

  let specificFormat = '';
  switch (contentType) {
    case 'faq':
      specificFormat = `"generatedContent": { "faqs": [{"question": "Question text here", "answer": "Detailed answer here"}] }`;
      break;
    case 'meta-tags':
      specificFormat = `"generatedContent": { "metaTags": {"title": "SEO title (60 chars max)", "description": "Meta description (160 chars max)", "keywords": "keyword1, keyword2"} }`;
      break;
    case 'snippets':
      specificFormat = `"generatedContent": { "snippet": "Direct answer for snippets", "raw": "The same content as snippet" }`;
      break;
    case 'headings':
      specificFormat = `"generatedContent": { "headingStructure": {"h1": "Main heading", "sections": [{"h2": "Section heading", "h3s": ["Subsection 1"]}]}, "raw": "H1: Main heading..." }`;
      break;
    case 'descriptions':
      specificFormat = `"generatedContent": { "description": "Compelling description", "raw": "The same content as description" }`;
      break;
  }

  return `You are an Expert Content Strategist and SEO Copywriter.
**Task:** Generate content based on the following criteria.
- **Content Type:** ${contentType}
- **Primary Topic:** ${topic}
- **Target Keywords:** ${targetKeywords.join(', ')}
- **Tone:** ${tone || 'professional'}
${entityInstruction}

**Instructions:**
${baseInstructions[contentType]}
- Ensure all content is high-quality, accurate, and ready for publication.
- Naturally incorporate ALL target keywords where appropriate.

**CRITICAL: You MUST provide your response in a single, valid JSON object enclosed in a \`\`\`json markdown block.**
The JSON object must follow this exact structure:
\`\`\`json
{
  "generatedTitle": "Engaging title for the content",
  ${specificFormat},
  "optimizationTips": [
    "Tip 1 about how to use this content effectively",
    "Tip 2 about SEO best practices"
  ],
  "supportingDetails": {
    "wordCount": "number",
    "keywordsUsed": ["array", "of", "keywords"],
    "aiOptimizationScore": "number_between_1_and_100"
  }
}
\`\`\`

Generate the content now.`;
};


// --- TOOL-SPECIFIC: Main Logic ---
const contentGeneratorToolLogic = async (req: Request, { supabaseClient, supabaseAdminClient }: { supabaseClient: SupabaseClient, supabaseAdminClient: SupabaseClient }) => {
  let runId: string | null = null;
  try {
    const requestBody: ContentGenerationRequest = await req.json();
    const { projectId, ...inputPayload } = requestBody;
    
    console.log('Content generator request for project:', projectId);
    
    if (!projectId) throw new Error("projectId is required.");
    if (!requestBody.topic || !requestBody.contentType) {
      throw new Error('`topic` and `contentType` are required fields.');
    }
    const validContentTypes = ['faq', 'meta-tags', 'snippets', 'headings', 'descriptions'];
    if (!validContentTypes.includes(requestBody.contentType)) {
      throw new Error(`Invalid contentType. Must be one of: ${validContentTypes.join(', ')}`);
    }

    // Check user has access to the project
    const { data: project, error: projectError } = await supabaseClient.from('projects').select('id').eq('id', projectId).single();
    if (projectError || !project) {
        throw new Error(`Access denied or project not found for id: ${projectId}`);
    }

    runId = await logToolRun(supabaseAdminClient, projectId, 'ai-content-generator', inputPayload);
    console.log(`Tool run logged with ID: ${runId}`);

    const geminiApiKey = Deno.env.get('GEMINI_API_KEY');
    if (!geminiApiKey) {
      throw new Error('Gemini API key not configured');
    }

    const prompt = getContentGenerationPrompt(requestBody);
    const generatedJson = await callGeminiWithRetry(prompt, geminiApiKey);

    if (!generatedJson.generatedTitle || !generatedJson.generatedContent) {
      console.error('Invalid generated JSON structure:', generatedJson);
      throw new Error('Generated content missing required fields');
    }

    const finalOutput = {
        ...generatedJson,
        generatedAt: new Date().toISOString(),
        contentType: requestBody.contentType,
    };

    console.log('Final generated content:', JSON.stringify(finalOutput, null, 2));

    await updateToolRun(supabaseAdminClient, runId, 'completed', finalOutput, null);
    return createSuccessResponse({ runId, ...finalOutput });

  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred.';
    console.error('Content generator error:', err);
    
    if (runId) {
      await updateToolRun(supabaseAdminClient, runId, 'error', null, errorMessage);
    }

    return createErrorResponse(errorMessage, 500, err instanceof Error ? err.stack : undefined);
  }
};


// --- Server ---
Deno.serve((req) => serviceHandler(req, contentGeneratorToolLogic));
