import { createClient, SupabaseClient } from "https://esm.sh/@supabase/supabase-js@2";

// --- SHARED: CORS Headers ---
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// --- SHARED: Response Helpers ---
function createErrorResponse(message: string, status = 500, details?: any) {
  return new Response(JSON.stringify({
    success: false,
    error: {
      message,
      details: details || undefined,
    }
  }), {
    status,
    headers: { ...corsHeaders, "Content-Type": "application/json" },
  });
}

function createSuccessResponse(data: object, status = 200) {
  return new Response(JSON.stringify({
    success: true,
    data,
  }), {
    status,
    headers: { ...corsHeaders, "Content-Type": "application/json" },
  });
}

// --- SHARED: Service Handler ---
async function serviceHandler(req: Request, toolLogic: Function) {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }
  try {
    const supabaseAdminClient = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!
    );

    // User may or may not be logged in for this tool
    const authHeader = req.headers.get('Authorization');
    let user = null;
    let supabaseClient = supabaseAdminClient; // Default to admin client

    if (authHeader) {
        supabaseClient = createClient(
          Deno.env.get("SUPABASE_URL")!,
          Deno.env.get("SUPABASE_ANON_KEY")!,
          { global: { headers: { Authorization: authHeader } } }
        );
        const { data } = await supabaseClient.auth.getUser();
        if (data.user) {
            user = data.user;
        }
    }

    return await toolLogic(req, { user, supabaseClient, supabaseAdminClient });

  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'An unknown server error occurred.';
    console.error(`[ServiceHandler Error]`, err);
    return createErrorResponse(errorMessage, 500, err instanceof Error ? err.stack : undefined);
  }
}

// --- SHARED: Database Logging Helpers ---
async function logToolRun(supabase: SupabaseClient, projectId: string, toolName: string, inputPayload: object) {
  // Not logging chatbot conversations to tool_runs to avoid clutter
  return "chatbot_run"; // Return a dummy ID
}

async function updateToolRun(supabase: SupabaseClient, runId: string, status: string, outputPayload: object | null, errorMessage: string | null) {
  // Not logging chatbot conversations to tool_runs
  return;
}

// --- SHARED: Robust AI Call Function ---
async function callGeminiWithRetry(prompt: string, apiKey: string) {
  let attempts = 0;
  const maxAttempts = 4;
  let delay = 1000;

  while (attempts < maxAttempts) {
    try {
      const geminiResponse = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }] }],
            generationConfig: {
              temperature: 0.7,
              maxOutputTokens: 1024,
            },
          }),
        }
      );

      if (!geminiResponse.ok) {
        if (geminiResponse.status === 429 || geminiResponse.status === 503) {
            const errorText = await geminiResponse.text();
            throw new Error(`Retryable Gemini API error: ${geminiResponse.status} ${errorText}`);
        }
        const errorText = await geminiResponse.text();
        console.error('Gemini API error:', geminiResponse.status, errorText);
        throw new Error(`Gemini API failed with status ${geminiResponse.status}: ${errorText}`);
      }

      const geminiData = await geminiResponse.json();
      const candidate = geminiData.candidates?.[0];
      if (!candidate) throw new Error('No content generated by Gemini API');

      const responseText = candidate.content?.parts?.[0]?.text;
      if (!responseText) throw new Error('Invalid response structure from Gemini API');

      console.log('Raw Gemini response text:', responseText.substring(0, 500) + '...');

      const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/);
      if (!jsonMatch || !jsonMatch[1]) {
        console.error('Could not find JSON block in response:', responseText);
        // Fallback for cases where the model might forget the markdown
        if (responseText.trim().startsWith("{")) {
            return JSON.parse(responseText.trim());
        }
        throw new Error('Failed to extract JSON from AI response.');
      }
      const jsonString = jsonMatch[1];
      console.log('Extracted JSON string:', jsonString);

      return JSON.parse(jsonString);

    } catch (error) {
       if (error.message.includes("Retryable")) {
            attempts++;
            console.log(`AI model is overloaded or rate-limited. Retrying in ${delay / 1000}s... (Attempt ${attempts}/${maxAttempts})`);
            await new Promise(resolve => setTimeout(resolve, delay));
            delay *= 2;
       } else {
           throw error;
       }
    }
  }
  throw new Error("The AI model is currently overloaded after multiple retries.");
}


// --- TOOL-SPECIFIC: Type Definitions ---
interface ChatRequest {
    projectId?: string; // Optional, as chatbot can be used outside a project
    message: string;
    context: 'dashboard' | 'landing';
    userPlan?: string;
    conversationHistory?: { role: 'user' | 'assistant'; content: string }[];
}

// --- TOOL-SPECIFIC: AI Prompt Engineering ---
const getChatPrompt = (request: ChatRequest, enhancedUserData: any): string => {
    const { message, context, userPlan, conversationHistory = [] } = request;
    const jsonSchema = `{ "responseText": "string", "suggestedFollowUps": ["string"] }`;

    return `You are Genie, an expert, friendly, and helpful AI assistant for SEOGENIX.
- **Current Context:** The user is on the '${context}' page.
- **User's Subscription Plan:** ${userPlan || (enhancedUserData ? 'Logged In' : 'Not logged in')}.
- **User's Data:** ${JSON.stringify(enhancedUserData, null, 2)}
- **Conversation History:**
  ${conversationHistory.map(msg => `${msg.role}: ${msg.content}`).join('\n')}
  user: ${message}

**Instructions:**
Based on the full context, generate a helpful and concise response to the user's message. Provide a few relevant follow-up questions.

**CRITICAL: You MUST provide your response in a single, valid JSON object enclosed in a \`\`\`json markdown block.**
The JSON object must strictly adhere to this schema:
\`\`\`json
${jsonSchema}
\`\`\`
Generate your response as Genie.`;
};


// --- TOOL-SPECIFIC: Main Logic ---
const chatbotToolLogic = async (req: Request, { user, supabaseClient, supabaseAdminClient }: { user: any, supabaseClient: SupabaseClient, supabaseAdminClient: SupabaseClient }) => {
  try {
    const requestBody: ChatRequest = await req.json();
    const { message, context } = requestBody;

    if (!message || !context) {
      return createErrorResponse('`message` and `context` are required.', 400);
    }

    console.log(`Chatbot request in context: ${context}`);

    let enhancedUserData = null;
    if (user && context === 'dashboard') {
        try {
            console.log(`Fetching profile for user: ${user.id}`);
            const { data: profile } = await supabaseClient.from('user_profiles').select('business_description, website_url, target_audience').eq('id', user.id).single();
            const { data: auditHistory } = await supabaseClient.from('audit_history').select('score, created_at').eq('user_id', user.id).order('created_at', { ascending: false }).limit(1);
            enhancedUserData = { profile, lastAudit: auditHistory?.[0] };
            console.log('Successfully fetched enhanced user data.');
        } catch (error) {
            console.error('Error fetching user data for chatbot:', error);
        }
    }

    const geminiApiKey = Deno.env.get('GEMINI_API_KEY');
    if (!geminiApiKey) throw new Error('Gemini API key not configured');

    const prompt = getChatPrompt(requestBody, enhancedUserData);
    const analysisJson = await callGeminiWithRetry(prompt, geminiApiKey);

    if (!analysisJson.responseText || !analysisJson.suggestedFollowUps) {
      throw new Error('Generated chat response missing required fields.');
    }

    const output = { ...analysisJson, personalized: !!enhancedUserData };
    return createSuccessResponse(output);

  } catch (err) {
    const errorMessage = err instanceof Error ? err.message : 'An unknown error occurred.';
    console.error('Chatbot tool error:', err);
    return createErrorResponse(errorMessage, 500, err instanceof Error ? err.stack : undefined);
  }
};

// --- Server ---
Deno.serve((req) => serviceHandler(req, chatbotToolLogic));
